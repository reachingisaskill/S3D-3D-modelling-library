
#include "S3D_intersections.h"

#include <cmath>

namespace S3D
{

  // Creation operators


  subtraction operator-( stdexts::sharedPtr< volume_base > s1, stdexts::sharedPtr< volume_base > s2 )
  {
    return subtraction( s1, s2 );
  }


  addition operator+( stdexts::sharedPtr< volume_base > s1, stdexts::sharedPtr< volume_base > s2 )
  {
    return addition( s1, s2 );
  }


  intersection operator*( stdexts::sharedPtr< volume_base > s1, stdexts::sharedPtr< volume_base > s2 )
  {
    return intersection( s1, s2 );
  }


  exclusion operator^( stdexts::sharedPtr< volume_base > s1, stdexts::sharedPtr< volume_base > s2 )
  {
    return exclusion( s1, s2 );
  }



  // INTERACTION_BASE


  intersection_base::intersection_base( stdexts::sharedPtr< volume_base > s1, stdexts::sharedPtr< volume_base > s2, double r, threeVector pos, threeVector dir ) :
    volume_base( r, pos, dir ),
    _s1( s1 ),
    _s2( s2 ),
    _print1( true ),
    _print2( true )
  {
  }

  volume_base* intersection_base::_vol1() 
  {
    return _s1.get();
  }

  volume_base* intersection_base::_vol2() 
  {
    return _s2.get();
  }

  const volume_base* intersection_base::_vol1() const
  {
    return _s1.get();
  }

  const volume_base* intersection_base::_vol2() const
  {
    return _s2.get();
  }

  const volume_base* intersection_base::vol1() const
  {
    return _s1.get();
  }

  const volume_base* intersection_base::vol2() const
  {
    return _s2.get();
  }

//  void intersection_base::print( printer& p ) const
//  {
//    if ( this->print1() )
//    {
//      print_base* newShape = this->_vol1()->_print();
//
//      newShape->setOpacity( this->getOpacity() );
//      newShape->setColour( this->getRed(), this->getGreen(), this->getBlue() ); 
//
//      p.addShape( newShape );
//    }
//    if ( this->print2() )
//    {
//      print_base* newShape = this->_vol2()->_print();
//
//      newShape->setOpacity( this->getOpacity() );
//      newShape->setColour( this->getRed(), this->getGreen(), this->getBlue() ); 
//
//      p.addShape( newShape );
//    }
//  }

   // SUBTRACTION


  subtraction::subtraction( stdexts::sharedPtr< volume_base > s1, stdexts::sharedPtr< volume_base > s2 ) :
    intersection_base( s1, s2, s1->outerSq(), s1->center(), s1->direction() )
  {
  }


  bool subtraction::contains( threeVector pt ) const
  {
    return ( ( _vol1()->contains( pt ) ) && ( !_vol2()->Contains( pt ) ) );
  }

  bool subtraction::Contains( threeVector pt ) const
  {
    return ( ( _vol1()->Contains( pt ) ) && ( !_vol2()->contains( pt ) ) );
  }

  bool subtraction::crosses( ray l ) const
  {
    return ( ( ( _vol1()->crosses( l ) ) && ( !_vol2()->Contains( _vol1()->intersect( l ) ) ) ) || ( _vol2()->crosses( l ) && ( _vol1()->contains( _vol2()->intersect( l ) ) ) ) );
  }

  double subtraction::distance( ray l ) const
  {
    double shortestDist = HUGE_VAL;

    stdexts::fifo< double > dists1 = _vol1()->distances( l );
    while ( dists1 )
    {
      double tmp = *dists1;
      if ( ! _vol2()->Contains( l.start() + tmp*l.direction() ) )
        if ( ( tmp >= 0.0 ) && tmp < shortestDist ) shortestDist = tmp;
    }

    stdexts::fifo< double > dists2 = _vol2()->distances( l );
    while ( dists2 )
    {
      double tmp = *dists2;
      if ( _vol1()->contains( l.start() + tmp*l.direction() ) )
        if ( ( tmp >= 0.0 ) && tmp < shortestDist ) shortestDist = tmp;
    }
    return shortestDist;
  }

  stdexts::fifo< double > subtraction::distances( ray l ) const
  {
    return ( _vol1()->distances( l ) << _vol2()->distances( l ) );
  }

  threeVector subtraction::intersect( ray l ) const
  {
    return l.start() + this->distance( l )*l.direction();
  }

  print_base* subtraction::_print() const
  {
    // TODO : Make this correct!
    return _vol1()->_print();
  }



   // ADDITION



  addition::addition( stdexts::sharedPtr< volume_base > s1, stdexts::sharedPtr< volume_base > s2 ) :
    intersection_base( s1, s2, (s1->outerSq() + s2->outerSq() + (s1->center()-s2->center()).square() ), s1->center() + 0.5*( s2->center() - s1->center() ), s1->direction() )
  {
  }


  bool addition::contains( threeVector pt ) const
  {
    return ( _vol1()->contains( pt ) ) || ( _vol2()->contains( pt ) );
  }

  bool addition::Contains( threeVector pt ) const
  {
    return ( _vol1()->Contains( pt ) ) || ( _vol2()->Contains( pt ) );
  }


  bool addition::crosses( ray l ) const
  {
    return ( ( ( _vol1()->crosses( l ) ) && ( ! _vol2()->Contains( _vol1()->intersect( l ) ) ) ) || ( ( _vol2()->crosses( l ) ) && ( ! _vol1()->Contains( _vol2()->intersect( l ) ) ) ) );
  }

  double addition::distance( ray l ) const
  {
    double shortestDist = HUGE_VAL;

    stdexts::fifo< double > dists1 = _vol1()->distances( l );
    while ( dists1 )
    {
      double tmp = *dists1;
      if ( ! _vol2()->Contains( l.start() + tmp*l.direction() ) )
        if ( ( tmp >= 0.0 ) && tmp < shortestDist ) shortestDist = tmp;
    }

    stdexts::fifo< double > dists2 = _vol2()->distances( l );
    while ( dists2 )
    {
      double tmp = *dists2;
      if ( ! _vol1()->Contains( l.start() + tmp*l.direction() ) )
        if ( ( tmp >= 0.0 ) && tmp < shortestDist ) shortestDist = tmp;
    }
    return shortestDist;
  }

  stdexts::fifo< double > addition::distances( ray l ) const
  {
    return ( _vol1()->distances( l ) << _vol2()->distances( l ) );
  }

  threeVector addition::intersect( ray l ) const
  {
    return l.start() + this->distance( l )*l.direction();
  }

  print_base* addition::_print() const
  {
    // TODO : Make this correct!
    return _vol1()->_print();
  }


   // INTERSECTION



  intersection::intersection( stdexts::sharedPtr< volume_base > s1, stdexts::sharedPtr< volume_base > s2 ) :
    intersection_base( s1, s2, ( s1->outerSq() < s2->outerSq() ? s1->outerSq() : s2->outerSq() ), s1->center() + 0.5*( s2->center() - s1->center() ), s2->center()-s1->center() )
  {
  }


  bool intersection::contains( threeVector pt ) const
  {
    return ( _vol1()->contains( pt ) ) && ( _vol2()->contains( pt ) );
  }

  bool intersection::Contains( threeVector pt ) const
  {
    return ( _vol1()->Contains( pt ) ) && ( _vol2()->Contains( pt ) );
  }


  bool intersection::crosses( ray l ) const
  {
    return ( ( ( _vol1()->crosses( l ) ) && ( _vol2()->contains( _vol1()->intersect( l ) ) ) ) || ( ( _vol2()->crosses( l ) ) && ( _vol1()->contains( _vol2()->intersect( l ) ) ) ) );
  }

  double intersection::distance( ray l ) const
  {
    double shortestDist = HUGE_VAL;

    stdexts::fifo< double > dists1 = _vol1()->distances( l );
    while ( dists1 )
    {
      double tmp = *dists1;
      if ( _vol2()->contains( l.start() + tmp*l.direction() ) )
        if ( ( tmp >= 0.0 ) && tmp < shortestDist ) shortestDist = tmp;
    }

    stdexts::fifo< double > dists2 = _vol2()->distances( l );
    while ( dists2 )
    {
      double tmp = *dists2;
      if ( _vol1()->contains( l.start() + tmp*l.direction() ) )
        if ( ( tmp >= 0.0 ) && tmp < shortestDist ) shortestDist = tmp;
    }
    return shortestDist;
  }

  stdexts::fifo< double > intersection::distances( ray l ) const
  {
    return ( _vol1()->distances( l ) << _vol2()->distances( l ) );
  }

  threeVector intersection::intersect( ray l ) const
  {
    return l.start() + this->distance( l )*l.direction();
  }

  print_base* intersection::_print() const
  {
    // TODO : Make this correct!
    return _vol1()->_print();
  }


   // EXCLUSION



  exclusion::exclusion( stdexts::sharedPtr< volume_base > s1, stdexts::sharedPtr< volume_base > s2 ) :
    intersection_base( s1, s2, (s1->outerSq() + s2->outerSq() + (s1->center()-s2->center()).square() ), s1->center() + 0.5*( s2->center() - s1->center() ), s1->direction() )
  {
  }


  bool exclusion::contains( threeVector pt ) const
  {
    return ( _vol1()->contains( pt ) ) ^ ( _vol2()->contains( pt ) );
  }

  bool exclusion::Contains( threeVector pt ) const
  {
    return ( _vol1()->Contains( pt ) ) ^ ( _vol2()->Contains( pt ) );
  }


  bool exclusion::crosses( ray l ) const
  {
    return ( ( _vol1()->crosses( l ) ) || ( _vol2()->crosses( l ) ) );
  }

  double exclusion::distance( ray l ) const
  {
    double shortestDist = HUGE_VAL;

    stdexts::fifo< double > dists1 = _vol1()->distances( l );
    while ( dists1 )
    {
      double tmp = *dists1;
      if ( ( tmp >= 0.0 ) && tmp < shortestDist ) shortestDist = tmp;
    }

    stdexts::fifo< double > dists2 = _vol2()->distances( l );
    while ( dists2 )
    {
      double tmp = *dists2;
      if ( ( tmp >= 0.0 ) && tmp < shortestDist ) shortestDist = tmp;
    }
    return shortestDist;
  }

  stdexts::fifo< double > exclusion::distances( ray l ) const
  {
    return ( _vol1()->distances( l ) << _vol2()->distances( l ) );
  }

  threeVector exclusion::intersect( ray l ) const
  {
    return l.start() + this->distance( l )*l.direction();
  }

  print_base* exclusion::_print() const
  {
    // TODO : Make this correct!
    return _vol1()->_print();
  }

}

